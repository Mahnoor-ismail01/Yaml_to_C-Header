!!python/object/apply:collections.OrderedDict
- - - $schema
    - inst_schema.json#
  - - kind
    - instruction
  - - name
    - andn
  - - long_name
    - AND with inverted operand
  - - description
    - 'Performs the bitwise logical AND operation between `xs1` and the

      bitwise inversion of `xs2`.

      '
  - - definedBy
    - !!python/object/apply:collections.OrderedDict
      - - - anyOf
          - - Zbb
            - Zbkb
  - - assembly
    - xd, xs1, xs2
  - - format
    - !!python/object/apply:collections.OrderedDict
      - - - $inherits
          - - inst_subtype/R/R-x.yaml#/data
        - - opcodes
          - !!python/object/apply:collections.OrderedDict
            - - - funct7
                - !!python/object/apply:collections.OrderedDict
                  - - - display_name
                      - ANDN
                    - - value
                      - 32
              - - funct3
                - !!python/object/apply:collections.OrderedDict
                  - - - display_name
                      - ANDN
                    - - value
                      - 7
              - - opcode
                - !!python/object/apply:collections.OrderedDict
                  - - - $inherits
                      - inst_opcode/OP.yaml#/data
  - - access
    - !!python/object/apply:collections.OrderedDict
      - - - s
          - always
        - - u
          - always
        - - vs
          - always
        - - vu
          - always
  - - data_independent_timing
    - true
  - - operation()
    - "if (implemented?(ExtensionName::B) && (CSR[misa].B == 1'b0)) {\n  raise (ExceptionCode::IllegalInstruction,\
      \ mode(), $encoding);\n}\n\nX[xd] = X[xs2] & ~X[xs1];\n"
  - - sail()
    - "{\n  let rs1_val = X(rs1);\n  let rs2_val = X(rs2);\n  let result : xlenbits\
      \ = match op {\n    RISCV_ANDN => rs1_val & ~(rs2_val),\n    RISCV_ORN  => rs1_val\
      \ | ~(rs2_val),\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\n    RISCV_MAX  =>\
      \ to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\n    RISCV_MAXU\
      \ => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\n   \
      \ RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\n\
      \    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\n\
      \    RISCV_ROL  => if sizeof(xlen) == 32\n                  then rs1_val <<<\
      \ rs2_val[4..0]\n                  else rs1_val <<< rs2_val[5..0],\n    RISCV_ROR\
      \  => if sizeof(xlen) == 32\n                  then rs1_val >>> rs2_val[4..0]\n\
      \                  else rs1_val >>> rs2_val[5..0]\n  };\n  X(rd) = result;\n\
      \  RETIRE_SUCCESS\n}\n"
